# lab1实验总结

## 练习一



## 练习二



## 练习三

1.为何要开启A20？如何开启A20？

在8086中，只有20根地址总线，可以访问的地址是1M，而8086是16位地址模式，为了能访问1M内存，其计算地址方法为：16位基地址左移4位+16位偏移=20位地址。但这种方式能够表示的最大内存10FFEFh，所以当程序员给出超过1M（100000h-10FFEFh）的地址时，系统并不认为其访问越界而产生异常，而是自动从0开始计算，也就是说系统计算实际地址的时候是按照对1M求模的方式进行的。从80286开始能够访问的内存空间超过了1M，为了解决兼容性问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根），被称为A20Gate，把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。如果A20Gate被打开，则当程序员给出100000h-10FFEFH之间的地址的时候，系统将真正访问这块区域内存。在实模式下，即使打开A20Gate，能访问的最大内存也只有10FFEFh，所以A20并不是开启保护模式的关键，但A20是保护模式下访问更大内存空间的关键，保护模式就是以A20地址线开启为前提，访问更大的内存空间。

打开A20地址线控制，需要向键盘控制器8042发送一个命令来完成。键盘控制器8042会将它的某个输出引脚的输出置高电平，作为A20地址线控制的输入。8042控制器输出端口P2的位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用户控制A20信号线的开启与否。开启A20的方法是通过设置8042芯片输出端口P2的第二位，将其置为高电位1。

当我们向8042芯片输出端口进行写操作的时候，在键盘缓冲区或许还有别的数据尚未处理，所以需要先处理这些数据。通过阅读bootmain.S代码可知，开启A20的步骤为：
等待8042的inputbuffer为空，
发送write请求到8042的inputbuffer，
等待8042的inputbuffer为空，
将8042输出端口的A20位置1。
具体操作在bootmain.S的代码中给出了中文注释。

2.如何初始化GDT表？

一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可。
~~~
lgdt gdtdesc        #将GDT入口地址存到gdtdesc寄存器里
~~~

在整个系统中GDT只有一张，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个寄存器用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。寄存器中存放的是GDT在内存中的基地址和其表长界限。
具体操作在bootmain.S的代码中给出了中文注释。

3.如何进入保护模式？

通过将cr0寄存器的PE位置1，进入保护模式，然后用一个长跳转指令让系统开始使用32位的寻址模式。
~~~
ljmp $ PROT_MODE_CSEG, $ protcseg；
~~~

PROT_MODE_CSEG代表段选择子，$protcseg代表接下来指令的链接地址，也就是可执行程序在内存中的虚拟地址。
进入保护模式后，程序重新对段寄存器进行初始化并且建立堆栈，设置堆栈指针。
转到保护模式完成，进入bootmain.c
具体操作在bootmain.S的代码中给出了中文注释。

## 练习四

1.bootloader如何读取硬盘扇区？

考虑到实现 的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作 是通过CPU访问硬盘的IO地址寄存器完成。
24-bit LBA方式:
写0x1f1: 0，写0x1f2: 要读的扇区数，写0x1f3: LBA参数的0-7位，写0x1f4: LBA参数的8~15位，写0x1f5: LBA参数的16-23位，写0x1f6: 75位,111,第4位0表示主盘,1表示从盘,30位,LBA参数的24-27位，写0x1f7: 0x20为读, 0x30为写，读0x1f7: 第4位为0表示读写完成，否则要一直循环等待，读0x1f0: 每次读取1个word,反复循环，直到读完所有数据。

当前硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程大致如下：
1.等待磁盘准备好
2.发出读取扇区的命令 
3.等待磁盘准备好 
4.把磁盘扇区数据读到指定内存
具体操作在bootmain.c的代码中给出了中文注释。

2.bootloader如何加载ELF格式的OS？
ELF header在文件开始处描述了整个文件的组织。ELF的文件头包含整个执行文件的控制结构，其定义在elf.h中，e_magic，是用来判断读出来的ELF格式的文件是否为正确的格式；e_phoff，是program header表的位置偏移；e_phnum，是program header表中的入口数目；e_entry，是程序入口所对应的虚拟地址。

program	header描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的 映像，同时包含其他一些用来为程序创建进程映像所必需的信息。可执行文件的程序头部是 一个program header结构的数组，每个结构描述了一个段或者系统准备程序执行所必需的其 它信息。目标文件的“段”包含一个或者多个“节区”（section），也就是“段内容（Segment Contents）”。程序头部仅对于可执行文件和共享目标文件有意义。可执行目标文件在ELF头 部的e_phentsize和e_phnum成员中给出其自身程序头部的大小。根据elfhdr和proghdr的结构描述，bootloader就可以完成对ELF格式的ucore操作系统的加载过程。

加载ELF格式的OS方法是：首先我们从硬盘将扇区数据存到内存0x10000处，主要的是将其转换为ELF格式。之后我们需要通过存储于头部的幻数来判断ELF的格式是否正确，再根据偏移量分别把程序段的数据读取到内存中，最后根据入口信息，找到内核的入口。
具体操作在bootmain.c和elf.h的代码中给出了中文注释。


## 练习五

根据代码中提供的函数和注释完成**print_stackframe**函数的实现，打印出和示例差不多的输出。

根据函数调用时栈帧的变化，上一个函数栈的顶部存储的是调用者ebp的地址，而ebp+4存储的是返回地址，即调用者的代码地址，返回地址之上的ebp+8存储的是可能的参数。

我们最后一行的输出为

~~~
ebp:0x00007bf8 eip:0x00007d74 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
~~~



最后一行打印的是我们的函数开始之前最早进入堆栈的函数，即读取磁盘扇区的ELF的bootmain.c中的bootmain函数，得知此函数的ebp为0x7bf8.

## 练习六

根据mmu.h中的定义，每一个表项占8个字节，其中第2-3字节是段选择址，1-2是低十六位偏移量，7-8是高十六位偏移量，他们共同构成了中断处理代码入口。

对于两个函数的修改见代码。

其中，对于trap.c的代码的修改中，本身我想通过定义一个变量累加判断，但是总是报错，参考了提供的答案发现在某个头文件中包含了这个变量的定义，其实阅读代码关注这个细节挺难的。